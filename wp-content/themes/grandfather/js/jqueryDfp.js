import utilities from './modules/utilities/index';
import event_tracking from './modules/analytics/eventTracking';

// Save Scope
const dfpScript = this || {};

// Ad Slot Refresh
window.desktop_refresh_box3 = $('body').attr('data-box3');
window.mobile_refresh_lead1 = $('body').attr('data-lead1');
window.mobile_refresh_lead2 = $('body').attr('data-lead2');

// Refresh timing
const desktopRefreshRate = $('body').attr('data-desktop') ? $('body').attr('data-desktop') * 1000 : 30000;
const mobileRefreshRate = $('body').attr('data-mobile') ? $('body').attr('data-mobile') * 1000 : 30000;

// Ad slots to set up for refresh
const desktopRefreshSlots = ['box3'];
const mobileRefreshSlots = ['lead1', 'lead2'];

// Used to trigger first ad call after setup is done
let firstCall = true;

// DFP account ID
let dfpID = '',
  // Init counters
  count = 0,
  uid = 0,
  rendered = 0,

  // Default DFP selector
  dfpSelector = '.adunit:first',

  adsCouldNeverBeInitilized = false,

  // Keep track of if we've already tried to load gpt.js before
  dfpIsLoaded = false,

  // Store adunit on div as:
  storeAs = 'googleAdUnit',

  /**
   * Get the id of the adUnit div or generate a unique one.
   * @param  Object $adUnit     The adunit to work with
   * @param  String adUnitName The name of the adunit
   * @return String             The ID of the adunit or a unique autogenerated ID
   */
  getID = function ($adUnit, adUnitName) {
    uid++;
    return $adUnit.attr('id') || $adUnit.attr('id', `${adUnitName.replace(/[^A-z0-9]/g, '_')}-auto-gen-id-${uid}`).attr('id');
  },

  generateAmazonBidderObject = function ($ad) {
    const currentMapping = window.fatherlyMapping[$ad.attr('data-size-mapping')];
    let adInfo = {
      slotID: String(getID($ad)),
      SlotName: String($ad.attr('data-adunit')),
    };

    for (let sizes in currentMapping) {
      if (currentMapping[sizes].browser[0] <= window.innerWidth) {
        adInfo.sizes = currentMapping[sizes].ad_sizes;
        return adInfo;
      }
    }
  },
  /**
   * Display all created Ads
   * @param {Object} dfpOptions options related to ad instantiation
   * @param {jQuery} $adCollection collection of ads
   */
  displayAds = function (dfpOptions, $adCollection) {
    const { googletag } = window;
    // Check if google adLoader can be loaded, this will work with AdBlock
    if (dfpScript.shouldCheckForAdBlockers() && !googletag._adBlocked_ && !window.isScroll) { // eslint-disable-line no-underscore-dangle
      if (googletag.getVersion) {
        const script = `//partner.googleadservices.com/gpt/pubads_impl_${
          googletag.getVersion()}.js`;
        $.getScript(script).always((r) => {
          if (r && r.statusText === 'error') {
            $.each($adCollection, function () {
              dfpOptions.afterAdBlocked.call(dfpScript, $(this));
            });
          }
        });
      }
    }

    $adCollection.each(function () {
      let $adUnit = $(this),
        $adUnitData = $adUnit.data(storeAs);

      if (googletag._adBlocked_) { // eslint-disable-line no-underscore-dangle
        if (dfpScript.shouldCheckForAdBlockers()) {
          dfpOptions.afterAdBlocked.call(dfpScript, $adUnit);
        }
      }

      let biddingObject = generateAmazonBidderObject($adUnit);
      if (biddingObject.sizes.length > 0 && !$adUnit.attr('data-size-mapping').includes('oop')) {
        apstag.fetchBids({
          slots: [generateAmazonBidderObject($adUnit)],
          timeout: 1e3,
        }, (bids) => {
          // set apstag targeting on googletag, then trigger
          // the first DFP request in googletag's disableInitialLoad integration
          googletag.cmd.push(() => {
            apstag.setDisplayBids();
            googletag.pubads().refresh([$adUnitData]);
          });
        });
      } else {
        googletag.cmd.push(() => { googletag.pubads().refresh([$adUnitData]); });
      }
    });
  },

  /**
   * Create an array of paths so that we can target DFP ads to Page URI's
   * @return Array an array of URL parts that can be targeted.
   */
  getUrlTargeting = function (url) {
    // Get the url and parse it to its component parts using regex from RFC2396 Appendix-B (https://tools.ietf.org/html/rfc2396#appendix-B)
    const urlMatches = (url || window.location.toString()).match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/);
    const matchedAuthority = urlMatches[4] || '';
    const matchedPath = (urlMatches[5] || '').replace(/(.)\/$/, '$1').substring(0, 40);
    const matchedQuery = urlMatches[7] || '';

    // Get the query params for targeting against
    const params = matchedQuery.replace(/=/ig, ':').split('&');

    return {
      Host: matchedAuthority,
      Path: matchedPath,
      Query: params,
    };
  },

  /**
   * Get the name of the Ad unit, either use the div id or
   * check for the optional attribute data-adunit
   * @param  Object $adUnit The adunit to work with
   * @param  Object dfpOptions options related to ad instantiation
   * @return String        The name of the adunit, will be the same as inside DFP
   */
  getName = function ($adUnit, dfpOptions) {
    let adUnitName = $adUnit.data('adunit') || dfpOptions.namespace || $adUnit.attr('id') || '';
    if (typeof dfpOptions.alterAdUnitName === 'function') {
      adUnitName = dfpOptions.alterAdUnitName.call(this, adUnitName, $adUnit);
    }
    return adUnitName;
  },

  /**
   * Get the dimensions of the ad unit using the container div dimensions or
   * check for the optional attribute data-dimensions
   * @param  Object $adUnit The adunit to work with
   * @return Array         The dimensions of the adunit (width, height)
   */
  getDimensions = function ($adUnit) {
    let dimensions = [],
      dimensionsData = $adUnit.data('dimensions');

    // Check if data-dimensions are specified. If they aren't, use the dimensions of the ad unit div.
    if (dimensionsData) {
      const dimensionGroups = dimensionsData.split(',');

      $.each(dimensionGroups, (k, v) => {
        if (v !== 'fluid') {
          const dimensionSet = v.split('x');
          dimensions.push([parseInt(dimensionSet[0], 10), parseInt(dimensionSet[1], 10)]);
        }

        if (v == 'fluid') {
          dimensions.push('fluid');
        }
      });
    } else {
      dimensions.push([$adUnit.width(), $adUnit.height()]);
    }

    return dimensions;
  },
  /**
   * This function gets called if DFP has been blocked by an adblocker
   * it implements a dummy version of the dfp object and allows the script to excute its callbacks
   * regardless of whether DFP is actually loaded or not... it is basically only useful for situations
   * where you are laying DFP over existing content and need to init things like slide shows after the loading
   * is completed.
   */
  dfpBlocked = function () {
    let { googletag } = window;
    // Get the stored dfp commands
    const commands = googletag.cmd;

    const defineSlotFunc = function (name, dimensions, id, oop) {
      googletag.ads.push(id);
      googletag.ads[id] = {
        renderEnded() { },
        addService() { return this; },
      };

      return googletag.ads[id];
    };

    // overwrite the dfp object - replacing the command array with a function and defining missing functions
    googletag = {
      cmd: {
        push(callback) {
          callback.call(dfpScript);
        },
      },
      ads: [],
      pubads() { return this; },
      noFetch() { return this; },
      disableInitialLoad() { return this; },
      disablePublisherConsole() { return this; },
      enableSingleRequest() { return this; },
      setTargeting() { return this; },
      collapseEmptyDivs() { return this; },
      enableServices() { return this; },
      defineSlot(name, dimensions, id) {
        return defineSlotFunc(name, dimensions, id, false);
      },
      defineOutOfPageSlot(name, id) {
        return defineSlotFunc(name, [], id, true);
      },
      display(id) {
        googletag.ads[id].renderEnded.call(dfpScript);
        return this;
      },

    };

    // Execute any stored commands
    $.each(commands, (k, v) => {
      googletag.cmd.push(v);
    });
  },
  /**
   * Call the google DFP script - there is a little bit of error detection in here to detect
   * if the dfp script has failed to load either through an error or it being blocked by an ad
   * blocker... if it does not load we execute a dummy script to replace the real DFP.
   *
   * @param {Object} options
   * @param {Array} $adCollection
   */
  dfpLoader = function (options, $adCollection) {
    function execBlockEvents() {
      if (dfpScript.shouldCheckForAdBlockers()) {
        $.each($adCollection, function () {
          options.afterAdBlocked.call(dfpScript, $(this));
        });
      }
    }

    // make sure we don't load gpt.js multiple times
    dfpIsLoaded = dfpIsLoaded || $('script[src*="googletagservices.com/tag/js/gpt.js"]').length;
    if (dfpIsLoaded) {
      if (adsCouldNeverBeInitilized) {
        execBlockEvents();
      }
      return $.Deferred().resolve();
    }

    const loaded = $.Deferred();

    window.googletag = window.googletag || {};
    window.googletag.cmd = window.googletag.cmd || [];

    const gads = document.createElement('script');
    gads.async = true;
    gads.type = 'text/javascript';

    const headerBid = document.createElement('script');
    headerBid.type = 'text/javascript';

    // Adblock blocks the load of Ad scripts... so we check for that
    gads.onerror = function () {
      dfpBlocked();
      loaded.resolve();
      adsCouldNeverBeInitilized = true;
      execBlockEvents();
    };

    gads.onload = function () {
      // this will work with ghostery:
      if (!googletag._loadStarted_) { // eslint-disable-line no-underscore-dangle
        googletag._adBlocked_ = true; // eslint-disable-line no-underscore-dangle
        execBlockEvents();
      }
      loaded.resolve();
    };

    const useSSL = document.location.protocol === 'https:';
    gads.src = `${useSSL ? 'https:' : 'http:'
    }//www.googletagservices.com/tag/js/gpt.js`;
    headerBid.src = envConfig.header_bidding;
    const node = document.getElementsByTagName('script')[0];
    node.parentNode.insertBefore(gads, node);
    node.parentNode.insertBefore(headerBid, node);

    // Adblock plus seems to hide blocked scripts... so we check for that
    if (gads.style.display === 'none') {
      dfpBlocked();
    }

    return loaded;
  },
  /**
   * Set the options for DFP
   * @param Object options Custom options to apply
   * @return Object extended options
   */
  setOptions = function (options) {
    // Set default options
    const dfpOptions = {
      setTargeting: {},
      setCategoryExclusion: '',
      setLocation: '',
      enableSingleRequest: true,
      collapseEmptyDivs: 'original',
      refreshExisting: true,
      disablePublisherConsole: false,
      disableInitialLoad: false,
      setCentering: false,
      noFetch: false,
      namespace: undefined,
      sizeMapping: {},
    };

    if (typeof options.setUrlTargeting === 'undefined' || options.setUrlTargeting) {
      // Get URL Targeting
      const urlTargeting = getUrlTargeting(options.setTargeting ? options.setTargeting.url : undefined);
      $.extend(true, dfpOptions.setTargeting, {
        UrlHost: urlTargeting.Host,
        UrlPath: urlTargeting.Path,
        UrlQuery: urlTargeting.Query,
      });
    }

    // Merge options objects
    $.extend(true, dfpOptions, options);

    // If a custom googletag is specified, use it.
    if (dfpOptions.googletag) {
      window.googletag.cmd.push(() => {
        $.extend(true, window.googletag, dfpOptions.googletag);
      });
    }

    return dfpOptions;
  },
  /**
   * Find and create all Ads
   * @param Object dfpOptions options related to ad instantiation
   * @param jQuery $adCollection collection of ads
   * @return Array an array of ad units that have been created.
   */
  createAds = function (dfpOptions, $adCollection, originalOptions) {
    const { googletag } = window;
    // Loops through on page Ad units and gets ads for them.
    $adCollection.each(function () {
      const $adUnit = $(this);

      count++;

      // adUnit name
      const adUnitName = getName($adUnit, dfpOptions);

      // adUnit id - this will use an existing id or an auto generated one.
      const adUnitID = getID($adUnit, adUnitName);

      // get dimensions of the adUnit
      const dimensions = getDimensions($adUnit);

      // set existing content
      $adUnit.data('existingContent', $adUnit.html());

      // wipe html clean ready for ad and set the default display class.
      $adUnit.html('').addClass('display-none');

      // Push commands to DFP to create ads
      googletag.cmd.push(function () {
        let googleAdUnit,
          $adUnitData = $adUnit.data(storeAs);

        if ($adUnitData) {
          // Get existing ad unit
          googleAdUnit = $adUnitData;
        } else {
          // Build slotName for loading
          let slotName;
          if (dfpID === '') {
            slotName = adUnitName;
          } else {
            slotName = `/${dfpID}/${adUnitName}`;
          }

          // Create the ad - out of page or normal
          if ($adUnit.data('outofpage')) {
            googleAdUnit = googletag.defineOutOfPageSlot(slotName, adUnitID);
          } else {
            googleAdUnit = googletag.defineSlot(slotName, dimensions, adUnitID);
            if ($adUnit.data('companion')) {
              googleAdUnit = googleAdUnit.addService(googletag.companionAds());
            }
          }

          googleAdUnit = googleAdUnit.addService(googletag.pubads());
        }


        // This means we are sending a single ad to display
        // Whatever params were passed with this specific ad needs to be used
        if (originalOptions.intitalRequest == false) {
          $.each(originalOptions.setTargeting, (k, v) => {
            googleAdUnit.setTargeting(k, v);
          });
        }

        // Sets custom targeting for just THIS ad unit if it has been specified
        const targeting = JSON.parse($adUnit.attr('data-targeting'));
        if (targeting) {
          $.each(targeting, (k, v) => {
            googleAdUnit.setTargeting(k, v);
          });
        }

        // Sets custom exclusions for just THIS ad unit if it has been specified
        const exclusions = $adUnit.data('exclusions');
        if (exclusions) {
          const exclusionsGroup = exclusions.split(',');
          let valueTrimmed;
          $.each(exclusionsGroup, (k, v) => {
            valueTrimmed = $.trim(v);
            if (valueTrimmed.length > 0) {
              googleAdUnit.setCategoryExclusion(valueTrimmed);
            }
          });
        }

        // Sets responsive size mapping for just THIS ad unit if it has been specified
        const mapping = $adUnit.data('size-mapping');
        if (mapping && dfpOptions.sizeMapping[mapping]) {
          // Convert verbose to DFP format
          const map = googletag.sizeMapping();
          $.each(dfpOptions.sizeMapping[mapping], (k, v) => {
            map.addSize(v.browser, v.ad_sizes);
          });
          googleAdUnit.defineSizeMapping(map.build());
        }

        // Store googleAdUnit reference
        $adUnit.data(storeAs, googleAdUnit);

        /*
         * Setup ad refresh on selected ads
         * Ad is refreshed only if ALL of the following conditions are met:
         * Refresh suppress variable is set to true
         * Refreshcount is below 50
         * Window width is above 999 (desktop) or below 600 (mobile)
         * Ad is in viewport
         * Tab is not hidden
         */

        if (window.outerWidth > 999) {
          for (let adSlot in desktopRefreshSlots) {
            if ($adUnit.data('size-mapping').includes(desktopRefreshSlots[adSlot])) {
              let refreshcount = 1;
              let variable = 'desktop_refresh_'.concat(desktopRefreshSlots[adSlot]);
              let refreshAd = setInterval(() => {
                if (window[variable] && utilities.is_in_viewport($adUnit[0])
                  && window.outerWidth > 999 && refreshcount < 51 && !document.hidden) {
                  googleAdUnit.setTargeting('refreshcount', refreshcount);
                  googletag.pubads().refresh([googleAdUnit]);
                  refreshcount++;
                } else {
                  clearInterval(refreshAd);
                }
              }, desktopRefreshRate);
            }
          }
        } else if (window.outerWidth < 600) {
          for (let adSlot in mobileRefreshSlots) {
            if ($adUnit.data('size-mapping').includes(mobileRefreshSlots[adSlot])) {
              let refreshcount = 1;
              let variable = 'mobile_refresh_'.concat(mobileRefreshSlots[adSlot]);
              let refreshAd = setInterval(() => {
                if (window[variable] && utilities.is_in_viewport($adUnit[0])
                  && window.outerWidth < 600 && refreshcount < 51 && !document.hidden) {
                  googleAdUnit.setTargeting('refreshcount', refreshcount);
                  googletag.pubads().refresh([googleAdUnit]);
                  refreshcount++;
                } else {
                  clearInterval(refreshAd);
                }
              }, mobileRefreshRate);
            }
          }
        }


        // Allow altering of the ad slot before ad load
        if (typeof dfpOptions.beforeEachAdLoaded === 'function') {
          dfpOptions.beforeEachAdLoaded.call(this, $adUnit);
        }
      });
    });

    // Push DFP config options
    googletag.cmd.push(() => {
      const pubadsService = googletag.pubads();

      if (dfpOptions.enableSingleRequest) {
        pubadsService.enableSingleRequest();
      }

      $.each(dfpOptions.setTargeting, (k, v) => {
        pubadsService.setTargeting(k, v);
      });

      const { setLocation } = dfpOptions;
      if (typeof setLocation === 'object') {
        if (typeof setLocation.latitude === 'number' && typeof setLocation.longitude === 'number'
          && typeof setLocation.precision === 'number') {
          pubadsService.setLocation(setLocation.latitude, setLocation.longitude, setLocation.precision);
        } else if (typeof setLocation.latitude === 'number' && typeof setLocation.longitude === 'number') {
          pubadsService.setLocation(setLocation.latitude, setLocation.longitude);
        }
      }

      if (dfpOptions.setCategoryExclusion.length > 0) {
        const exclusionsGroup = dfpOptions.setCategoryExclusion.split(',');
        let valueTrimmed;

        $.each(exclusionsGroup, (k, v) => {
          valueTrimmed = $.trim(v);
          if (valueTrimmed.length > 0) {
            pubadsService.setCategoryExclusion(valueTrimmed);
          }
        });
      }

      if (dfpOptions.collapseEmptyDivs) {
        pubadsService.collapseEmptyDivs();
      }

      if (dfpOptions.disablePublisherConsole) {
        pubadsService.disablePublisherConsole();
      }

      if (dfpOptions.companionAds) {
        googletag.companionAds().setRefreshUnfilledSlots(true);

        if (!dfpOptions.disableInitialLoad) {
          pubadsService.enableVideoAds();
        }
      }

      if (dfpOptions.disableInitialLoad) {
        pubadsService.disableInitialLoad();
      }

      if (dfpOptions.noFetch) {
        pubadsService.noFetch();
      }

      if (dfpOptions.setCentering) {
        pubadsService.setCentering(true);
      }

      // Setup event listener to listen for renderEnded event and fire callbacks.
      pubadsService.addEventListener('slotRenderEnded', function (event) {
        rendered++;

        const $adUnit = $(`#${event.slot.getSlotId().getDomId()}`);

        let display = event.isEmpty ? 'none' : 'block';

        // if the div has been collapsed but there was existing content expand the
        // div and reinsert the existing content.
        const $existingContent = $adUnit.data('existingContent');
        if (display === 'none' && $.trim($existingContent).length > 0
          && dfpOptions.collapseEmptyDivs === 'original') {
          $adUnit.show().html($existingContent);
          display = 'block display-original';
        }

        $adUnit.removeClass('display-none').addClass(`display-${display}`);

        // Excute afterEachAdLoaded callback if provided
        if (typeof dfpOptions.afterEachAdLoaded === 'function') {
          dfpOptions.afterEachAdLoaded.call(this, $adUnit, event);
        }

        // Excute afterAllAdsLoaded callback if provided
        if (typeof dfpOptions.afterAllAdsLoaded === 'function' && rendered === count) {
          dfpOptions.afterAllAdsLoaded.call(this, $adCollection);
        }
      });

      // this will work with AdblockPlus
      if (dfpScript.shouldCheckForAdBlockers() && !googletag._adBlocked_) { // eslint-disable-line no-underscore-dangle
        setTimeout(() => {
          const slots = pubadsService.getSlots ? pubadsService.getSlots() : [];
          if (slots.length > 0) {
            $.get(slots[0].getContentUrl()).always((r) => {
              if (r.status !== 200) {
                $.each(slots, function () {
                  const $adUnit = $(`#${this.getSlotId().getDomId()}`);
                  dfpOptions.afterAdBlocked.call(dfpScript, $adUnit, this);
                });
              }
            });
          }
        }, 0);
      }

      if (firstCall) {
        $(document).ready(() => {
          firstCall = false;
          googletag.pubads().disableInitialLoad();
          googletag.enableServices();
          $(window).trigger('dfpMappingLoaded');
        });
      }
    });
  },
  /**
   * Init function sets required params and loads Google's DFP script
   * @param  String id       The DFP account ID
   * @param  String selector The adunit selector
   * @param  Object options  Custom options to apply
   */
  init = function (id, selector, options) {
    let $adCollection;

    // Reset counters on each call
    count = 0;
    rendered = 0;

    dfpID = id;
    $adCollection = $(selector);

    // Get instance of options for enable single load option
    const originalOptions = options;

    /**
     * @returns {boolean}
     */
    dfpScript.shouldCheckForAdBlockers = function () {
      return options ? typeof options.afterAdBlocked === 'function' : false;
    };

    // explicitly wait for loader to be completed, otherwise the googletag might not be available
    dfpLoader(options, $adCollection).then(() => {
      options = setOptions(options);
      dfpScript.dfpOptions = options;

      $(() => {
        createAds(options, $adCollection, originalOptions);
        displayAds(options, $adCollection);
      });
    });
  };

/**
 * Add function to the jQuery / Zepto namespace
 * @param  String id      (Optional) The DFP account ID
 * @param  Object options (Optional) Custom options to apply
 */
$.dfp = $.fn.dfp = function (id, options) { // eslint-disable-line no-multi-assign
  options = options || {};

  if (id === undefined) {
    id = dfpID;
  }

  if (typeof id === 'object') {
    options = id;
    id = options.dfpID || dfpID;
  }

  let selector = this;

  if (typeof this === 'function') {
    selector = dfpSelector;
  }

  init(id, selector, options);

  return this;
};
